В строке ```public class JvmComprehension {}``` объявляется публичный (доступный всем) класс. В данный момент производится подгрузка необходимых классов, проверка валидности кода, связывание ссылок на классы и инициализация. Хранится информация класса в "Metaspase". 

В строке ```public static void main(String[] args) {}``` создается точка входа, с которой начинается работа
программы, JRE ищет для запуска именно этот метод. В стеке выделяется фрейм "main".

В строке ```int i = 1;``` объявляется переменная типа int, с именем "i" и значением 1. Данная локальная переменная
хранится в стеке во фрейме "main".

В строке ```Object o = new Object();```:

1. ```Object o``` в стеке во фрейме "main" создается ссылка типа Object с именем "о".
2. ```new Object();``` создается новый объект в хипе типа Object.

В строке ```Integer ii = 2;```* создается объект класса-обертки типа Integer:

1. ```Integer ii``` создается ссылка в стеке во фрейме "main" типа Integer с именем "ii".
2. ```ii = 2;``` объекту типа Integer под названием "ii" присваивается значение 2 и хранится в хипе.
3. *эта строка аналогична записи ```Integer ii = new Integer(2);```, но такая подробная формулировка не обязательна -
   компилятор на основе короткой записи генерирует полную версию.

В строке ```printAll(o, i, ii);``` вызывается статический метод:

1. ```printAll()``` - вызов самого метода
   1. ```(o, i, ii);``` - передача аргументов в метод
       * в строке ```private static void printAll(Object o, int i, Integer ii) {}``` создается приватный (видимый только в
         рамках класса JvmComprehension) статический метод. Данный метод не возвращает никаких значений, так как на месте
         возвращаемого типа стоит "void". Также в этот момент в стеке создается фрейм "printAll".
           * В сигнатуре метода также указано, что он обязательно должен принимать три
             аргумента ```(Object o, int i, Integer ii)``` - тут формируются ссылки в стеке во фрейме "printAll", которым,
             при вызове метода, будет передано значение уже существующих объектов, находящихся в хипе или в стеке, как локальные переменные: 
           ```
            Object o = new Object();
            int i = 1;
            Integer ii = 2;
           ```
       * в строке ```Integer uselessVar = 700;``` также, как описано выше создается объект класса-обертки типа Integer в
         стеке во фрейме "printAll". 
       * в строке ```System.out.println(o.toString() + i + ii);``` происходит вывод в консоль - у каждого объекта вызывается метод "toString" для создания строки (типа String), которая будет выведена. Эта строка будет создана в хипе, но т.к. этот объект не имеет на себя ссылку в стеке, он будет удален при следующем запуске Garbage collector.

В строке ```System.out.println("finished");``` в хипе создается объект типа String для передачи его в качестве аргумента методу "println()" для вывода на экран. В дальнейшем этот объект будет удален Garbage collector`ом за счет того, что в стеке не будет на него ссылки.